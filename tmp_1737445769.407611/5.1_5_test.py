from scicode.parse.parse import process_hdf5_to_tuple
import numpy as np

import numpy as np



# Background: The Lanczos algorithm is an iterative method used to approximate the eigenvalues and eigenvectors of large symmetric matrices.
# It is particularly useful for computing a few eigenvalues and eigenvectors of a large, sparse matrix. The method works by constructing 
# an orthonormal basis for the Krylov subspace, which is generated by repeatedly applying the matrix A to an initial vector b. The orthogonal 
# basis vectors are stored in the matrix Q, and are constructed using the Gram-Schmidt process to ensure orthogonality. The process is 
# repeated for m iterations, resulting in a tridiagonal matrix T that approximates A in the Krylov subspace. The columns of Q are the 
# orthonormal basis vectors.


def lanczos(A, b, m):
    '''Inputs:
    A : Matrix, 2d array of arbitrary size M * M
    b : Vector, 1d array of arbitrary size M * 1
    m : integer, m < M
    Outputs:
    Q : Matrix, 2d array of size M*(m+1)
    '''

    # Ensure b is a column vector
    b = b.reshape(-1, 1)

    # Initialize variables
    M = A.shape[0]
    Q = np.zeros((M, m + 1))
    alpha = np.zeros(m)
    beta = np.zeros(m + 1)
    
    # Normalize the initial vector b
    beta[0] = np.linalg.norm(b)
    Q[:, 0] = (b / beta[0]).flatten()

    for j in range(m):
        # Compute A * q_j
        v = A @ Q[:, j]

        # Orthogonalize against previous Q
        alpha[j] = Q[:, j].T @ v
        v = v - alpha[j] * Q[:, j] - beta[j] * Q[:, j - 1] if j > 0 else v - alpha[j] * Q[:, j]

        # Reorthogonalization might be needed in practice to improve numerical stability
        # v = v - Q @ (Q.T @ v)

        # Compute beta for next iteration
        beta[j + 1] = np.linalg.norm(v)

        # Normalize v to get the next basis vector
        if beta[j + 1] > 0:
            Q[:, j + 1] = (v / beta[j + 1]).flatten()

    return Q


try:
    targets = process_hdf5_to_tuple('5.1', 3)
    target = targets[0]
    n = 7
    h = 1.0/n
    diagonal = [2/h for i in range(n)]
    diagonal_up = [-1/h for i in range(n-1)]
    diagonal_down = [-1/h for i in range(n-1)]
    A = np.diag(diagonal) + np.diag(diagonal_up, 1) + np.diag(diagonal_down, -1)
    b = np.array([0.1,0.1,0.0,0.1,0.0,0.1,0.1])
    m = 5
    assert np.allclose(lanczos(A,b,m), target)

    target = targets[1]
    n = 7
    h = 1.0/n
    diagonal = [1/h for i in range(n)]
    diagonal_up = [-0.9/h for i in range(n-1)]
    diagonal_down = [-0.9/h for i in range(n-1)]
    A = np.diag(diagonal) + np.diag(diagonal_up, 1) + np.diag(diagonal_down, -1)
    b = np.array([0.1,10.1,0.0,0.5,0.2,0.3,0.5])
    m = 5
    assert np.allclose(lanczos(A,b,m), target)

    target = targets[2]
    n = 7
    h = 1.0/n
    diagonal = [1/h for i in range(n)]
    diagonal_up = [-9/h for i in range(n-1)]
    diagonal_down = [-9/h for i in range(n-1)]
    A = np.diag(diagonal) + np.diag(diagonal_up, 1) + np.diag(diagonal_down, -1)
    A[:, 0] = 0
    A[0, :] = 0
    A[0, 0] = 1/h
    b = np.array([0.1,0.1,0.0,10,0.0,0.1,0.1])
    m = 4
    assert np.allclose(lanczos(A,b,m), target)

except Exception as e:
    print(f'Error during execution: {str(e)}')
    raise e