import numpy as np



# Background: The Lanczos iteration is an algorithm used to approximate the eigenvalues and eigenvectors of a symmetric matrix. 
# It is particularly useful for large sparse matrices. The basic idea is to construct an orthonormal basis for the Krylov subspace 
# generated by the matrix and a starting vector. This basis is stored in the columns of matrix Q, which is built iteratively. 
# The process involves three-term recurrence relations that help maintain orthogonality of the vectors. Given a symmetric matrix A 
# and a starting vector b, the Lanczos algorithm generates a sequence of vectors that approximates the eigenvectors of A. The 
# number of iterations m determines the dimension of the Krylov subspace and hence controls the accuracy of the approximation.


def lanczos(A, b, m):
    '''Inputs:
    A : Matrix, 2d array of arbitrary size M * M
    b : Vector, 1d array of arbitrary size M * 1
    m : integer, m < M
    Outputs:
    Q : Matrix, 2d array of size M*(m+1)
    '''
    
    M = A.shape[0]
    Q = np.zeros((M, m + 1))  # Matrix to store the orthonormal vectors
    q = b / np.linalg.norm(b)  # Normalize the initial vector
    Q[:, 0] = q
    
    beta = 0
    for j in range(1, m + 1):
        w = A @ q
        if j > 1:
            w -= beta * Q[:, j - 1]
        alpha = np.dot(q.T, w)
        w -= alpha * q
        beta = np.linalg.norm(w)
        
        if beta < 1e-10:
            break
        
        q = w / beta
        Q[:, j] = q
    
    return Q

from scicode.parse.parse import process_hdf5_to_tuple
targets = process_hdf5_to_tuple('5.1', 3)
target = targets[0]

n = 7
h = 1.0/n
diagonal = [2/h for i in range(n)]
diagonal_up = [-1/h for i in range(n-1)]
diagonal_down = [-1/h for i in range(n-1)]
A = np.diag(diagonal) + np.diag(diagonal_up, 1) + np.diag(diagonal_down, -1)
b = np.array([0.1,0.1,0.0,0.1,0.0,0.1,0.1])
m = 5
assert np.allclose(lanczos(A,b,m), target)
target = targets[1]

n = 7
h = 1.0/n
diagonal = [1/h for i in range(n)]
diagonal_up = [-0.9/h for i in range(n-1)]
diagonal_down = [-0.9/h for i in range(n-1)]
A = np.diag(diagonal) + np.diag(diagonal_up, 1) + np.diag(diagonal_down, -1)
b = np.array([0.1,10.1,0.0,0.5,0.2,0.3,0.5])
m = 5
assert np.allclose(lanczos(A,b,m), target)
target = targets[2]

n = 7
h = 1.0/n
diagonal = [1/h for i in range(n)]
diagonal_up = [-9/h for i in range(n-1)]
diagonal_down = [-9/h for i in range(n-1)]
A = np.diag(diagonal) + np.diag(diagonal_up, 1) + np.diag(diagonal_down, -1)
A[:, 0] = 0
A[0, :] = 0
A[0, 0] = 1/h
b = np.array([0.1,0.1,0.0,10,0.0,0.1,0.1])
m = 4
assert np.allclose(lanczos(A,b,m), target)
